import streamlit as st
import cv2
from ultralytics import YOLO
import requests
from PIL import Image
import os
from glob import glob
from numpy import random
import io

os.environ['KMP_DUPLICATE_LIB_OK'] = 'True'

# Function to load the YOLO model
@st.cache_resource
def load_model(model_path):
    model = YOLO(model_path)
    return model

# Function to predict objects in the image
def predict_image(model, image, conf_threshold, iou_threshold):
    # Predict objects using the model
    res = model.predict(
        image,
        conf=conf_threshold,
        iou=iou_threshold,
        device='cpu',
    )
    
    class_name = model.model.names
    classes = res[0].boxes.cls
    class_counts = {}
    
    # Count the number of occurrences for each class
    for c in classes:
        c = int(c)
        class_counts[class_name[c]] = class_counts.get(class_name[c], 0) + 1

    # Generate prediction text
    prediction_text = 'Predicted '
    for k, v in sorted(class_counts.items(), key=lambda item: item[1], reverse=True):
        prediction_text += f'{v} {k}'
        
        if v > 1:
            prediction_text += 's'
        
        prediction_text += ', '

    prediction_text = prediction_text[:-2]
    if len(class_counts) == 0:
        prediction_text = "No objects detected"

    # Calculate inference latency
    latency = sum(res[0].speed.values())  # in ms, need to convert to seconds
    latency = round(latency / 1000, 2)
    prediction_text += f' in {latency} seconds.'

    # Convert the result image to RGB
    res_image = res[0].plot()
    res_image = cv2.cvtColor(res_image, cv2.COLOR_BGR2RGB)
    
    return res_image, prediction_text

def main():
    # Set Streamlit page configuration
    st.set_page_config(
        page_title="Wildfire Detection",
        page_icon="ðŸ”¥",
        layout="wide",
    )
    
    # Sidebar information
    st.sidebar.title("Settings")
    
    # Display logo in the sidebar
    logos = glob('dalle-logos/*.png')
    logo = random.choice(logos)
    st.sidebar.image(logo, use_column_width=True, caption="Generated by DALL-E")
    
    st.sidebar.markdown("Developed by Ayushi Jain and Mathew Thomas")
    
    # Model selection
    st.sidebar.subheader("Model Selection")
    model_type = st.sidebar.radio("Select Model Type", ("Fire Detection", "General"), index=0)
    models_dir = "general-models" if model_type == "General" else "fire-models"
    model_files = [f.replace(".pt", "") for f in os.listdir(models_dir) if f.endswith(".pt")]
    selected_model = st.sidebar.selectbox("Select Model Size", sorted(model_files), index=2)
    
    with st.sidebar.expander("What is General?"):
        st.write("The General model is an additional model that was added for demonstration purposes.")
        st.write("It is pre-trained on the COCO dataset, which consists of various objects across 80 classes.")
        st.write("Please note that this model may not be optimized specifically for fire detection.")
        st.write("For accurate fire and smoke detection, it is recommended to choose the Fire Detection model.")
        st.write("The General model can be used to detect objects commonly found in everyday scenes.")

    with st.sidebar.expander("Size Information"):
        st.write("Models are available in different sizes, indicated by n, s, m, and l.")
        st.write("- n: Nano")
        st.write("- s: Small")
        st.write("- m: Medium")
        st.write("- l: Large")
        st.write("The larger the model, the more precise the detections, but the slower the inference time.")
        st.write("On the other hand, smaller models are faster but may sacrifice some precision.")
        st.write("Choose a model based on the trade-off between speed and precision that best suits your needs.")
        
    # Load the selected model
    model_path = os.path.join(models_dir, selected_model + ".pt")
    model = load_model(model_path)

    # Set confidence and IOU thresholds
    st.sidebar.subheader("Threshold Settings")
    conf_threshold = st.sidebar.slider("Confidence Threshold", 0.0, 1.0, 0.20, 0.05)
    with st.sidebar.expander("What is Confidence Threshold?"):
        st.write("The Confidence Threshold is a value between 0 and 1.")
        st.write("It determines the minimum confidence level required for an object detection.")
        st.write("If the confidence of a detected object is below this threshold, it will be ignored.")
        st.write("You can adjust this threshold to control the number of detected objects.")
        st.write("Lower values make the detection more permissive, while higher values make it more strict.")
    iou_threshold = st.sidebar.slider("IOU Threshold", 0.0, 1.0, 0.5, 0.05)
    with st.sidebar.expander("What is IOU Threshold?"):
        st.write("The IOU (Intersection over Union) Threshold is a value between 0 and 1.")
        st.write("It determines the minimum overlap required between the predicted bounding box")
        st.write("and the ground truth box for them to be considered a match.")
        st.write("You can adjust this threshold to control the precision and recall of the detections.")
        st.write("Higher values make the matching more strict, while lower values allow more matches.")

    # App title and description
    st.title("ðŸ”¥ Wildfire Detection")
    st.write("Welcome to our Wildfire Detection App! Powered by the [YOLOv8](https://github.com/ultralytics/ultralytics) detection model trained on the [D-Fire](https://github.com/gaiasd/DFireDataset): an image dataset for fire and smoke detection.")
    st.write("Our goal is to prevent wildfires by detecting fire and smoke in images with high accuracy and speed.")
    st.write("Experience the effectiveness of our detection model by uploading an image or providing a URL.")

    # Add a separator
    st.markdown("---")
    
    # Image selection
    st.subheader("Upload Image")
    image = None
    image_source = st.radio("Select image source:", ("Upload from Computer", "Enter URL"))
    if image_source == "Upload from Computer":
        # File uploader for image
        uploaded_file = st.file_uploader("Upload an image", type=["png", "jpg", "jpeg"])
        if uploaded_file is not None:
            image = Image.open(uploaded_file)
    else:
        # Input box for image URL
        url = st.text_input("Enter the image URL:")
        if url:
            try:
                response = requests.get(url, stream=True)
                if response.status_code == 200:
                    image = Image.open(response.raw)
                else:
                    st.error("Error loading image from URL.")
            except requests.exceptions.RequestException as e:
                st.error(f"Error loading image from URL: {e}")

    if image:
        # Display the uploaded image
        st.image(image, caption="Uploaded Image", use_column_width=True)
        st.write("")
        if st.button("Run Detection"):
            with st.spinner("Detecting..."):
                prediction, text = predict_image(model, image, conf_threshold, iou_threshold)
                st.image(prediction, caption="Prediction", use_column_width=True)
                st.success(text)
            
            prediction = Image.fromarray(prediction)
    
            # Create a BytesIO object to temporarily store the image data
            image_buffer = io.BytesIO()
    
            # Save the image to the BytesIO object in PNG format
            prediction.save(image_buffer, format='PNG')
    
            # Create a download button for the image
            st.download_button(
                label='Download Prediction',
                data=image_buffer.getvalue(),
                file_name='prediction.png',
                mime='image/png'
            )
    else:
        st.info("Please upload an image or provide a valid URL.")

if __name__ == "__main__":
    main()
